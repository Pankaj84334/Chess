{
  "version": 3,
  "sources": ["../../chess.js/dist/esm/pgn.js", "../../chess.js/src/chess.ts"],
  "sourcesContent": ["// @generated by Peggy 4.2.0.\n//\n// https://peggyjs.org/\n\n\"use strict\";\n\n\n\n  function rootNode(comment) {\n  \treturn comment !== null ? { comment, variations: [] } : { variations: []}\n  }\n\n  function node(move, suffix, nag, comment, variations) {\n  \tconst node = { move, variations }\n\n    if (suffix) {\n    \tnode.suffix = suffix\n    }\n\n    if (nag) {\n    \tnode.nag = nag\n    }\n\n    if (comment !== null) {\n    \tnode.comment = comment\n    }\n\n    return node\n  }\n\n  function lineToTree(...nodes) {\n  \tconst [root, ...rest] = nodes;\n\n    let parent = root\n\n    for (const child of rest) {\n    \tif (child !== null) {\n        \tparent.variations = [child, ...child.variations]\n            child.variations = []\n            parent = child\n        }\n    }\n\n  \treturn root\n  }\n\n  function pgn(headers, game) {\n  \tif (game.marker && game.marker.comment) {\n    \tlet node = game.root\n        while (true) {\n        \tconst next = node.variations[0]\n            if (!next) {\n            \tnode.comment = game.marker.comment\n            \tbreak\n            }\n            node = next\n        }\n    }\n\n  \treturn {\n    \theaders,\n        root: game.root,\n        result: (game.marker && game.marker.result) ?? undefined\n    }\n  }\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  // istanbul ignore next Check is a necessary evil to support older environments\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var offset_s = (this.location.source && (typeof this.location.source.offset === \"function\"))\n      ? this.location.source.offset(s)\n      : s;\n    var loc = this.location.source + \":\" + offset_s.line + \":\" + offset_s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", offset_s.line.toString().length, ' ');\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      var hatLen = (last - s.column) || 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + offset_s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1, ' ')\n          + peg$padEnd(\"\", hatLen, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts.join(\"\") + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { pgn: peg$parsepgn };\n  var peg$startRuleFunction = peg$parsepgn;\n\n  var peg$c0 = \"[\";\n  var peg$c1 = \"\\\"\";\n  var peg$c2 = \"]\";\n  var peg$c3 = \".\";\n  var peg$c4 = \"O-O-O\";\n  var peg$c5 = \"O-O\";\n  var peg$c6 = \"0-0-0\";\n  var peg$c7 = \"0-0\";\n  var peg$c8 = \"$\";\n  var peg$c9 = \"{\";\n  var peg$c10 = \"}\";\n  var peg$c11 = \";\";\n  var peg$c12 = \"(\";\n  var peg$c13 = \")\";\n  var peg$c14 = \"1-0\";\n  var peg$c15 = \"0-1\";\n  var peg$c16 = \"1/2-1/2\";\n  var peg$c17 = \"*\";\n\n  var peg$r0 = /^[a-zA-Z]/;\n  var peg$r1 = /^[^\"]/;\n  var peg$r2 = /^[0-9]/;\n  var peg$r3 = /^[.]/;\n  var peg$r4 = /^[a-zA-Z1-8\\-=]/;\n  var peg$r5 = /^[+#]/;\n  var peg$r6 = /^[!?]/;\n  var peg$r7 = /^[^}]/;\n  var peg$r8 = /^[^\\r\\n]/;\n  var peg$r9 = /^[ \\t\\r\\n]/;\n\n  var peg$e0 = peg$otherExpectation(\"tag pair\");\n  var peg$e1 = peg$literalExpectation(\"[\", false);\n  var peg$e2 = peg$literalExpectation(\"\\\"\", false);\n  var peg$e3 = peg$literalExpectation(\"]\", false);\n  var peg$e4 = peg$otherExpectation(\"tag name\");\n  var peg$e5 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"]], false, false);\n  var peg$e6 = peg$otherExpectation(\"tag value\");\n  var peg$e7 = peg$classExpectation([\"\\\"\"], true, false);\n  var peg$e8 = peg$otherExpectation(\"move number\");\n  var peg$e9 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n  var peg$e10 = peg$literalExpectation(\".\", false);\n  var peg$e11 = peg$classExpectation([\".\"], false, false);\n  var peg$e12 = peg$otherExpectation(\"standard algebraic notation\");\n  var peg$e13 = peg$literalExpectation(\"O-O-O\", false);\n  var peg$e14 = peg$literalExpectation(\"O-O\", false);\n  var peg$e15 = peg$literalExpectation(\"0-0-0\", false);\n  var peg$e16 = peg$literalExpectation(\"0-0\", false);\n  var peg$e17 = peg$classExpectation([[\"a\", \"z\"], [\"A\", \"Z\"], [\"1\", \"8\"], \"-\", \"=\"], false, false);\n  var peg$e18 = peg$classExpectation([\"+\", \"#\"], false, false);\n  var peg$e19 = peg$otherExpectation(\"suffix annotation\");\n  var peg$e20 = peg$classExpectation([\"!\", \"?\"], false, false);\n  var peg$e21 = peg$otherExpectation(\"NAG\");\n  var peg$e22 = peg$literalExpectation(\"$\", false);\n  var peg$e23 = peg$otherExpectation(\"brace comment\");\n  var peg$e24 = peg$literalExpectation(\"{\", false);\n  var peg$e25 = peg$classExpectation([\"}\"], true, false);\n  var peg$e26 = peg$literalExpectation(\"}\", false);\n  var peg$e27 = peg$otherExpectation(\"rest of line comment\");\n  var peg$e28 = peg$literalExpectation(\";\", false);\n  var peg$e29 = peg$classExpectation([\"\\r\", \"\\n\"], true, false);\n  var peg$e30 = peg$otherExpectation(\"variation\");\n  var peg$e31 = peg$literalExpectation(\"(\", false);\n  var peg$e32 = peg$literalExpectation(\")\", false);\n  var peg$e33 = peg$otherExpectation(\"game termination marker\");\n  var peg$e34 = peg$literalExpectation(\"1-0\", false);\n  var peg$e35 = peg$literalExpectation(\"0-1\", false);\n  var peg$e36 = peg$literalExpectation(\"1/2-1/2\", false);\n  var peg$e37 = peg$literalExpectation(\"*\", false);\n  var peg$e38 = peg$otherExpectation(\"whitespace\");\n  var peg$e39 = peg$classExpectation([\" \", \"\\t\", \"\\r\", \"\\n\"], false, false);\n\n  var peg$f0 = function(headers, game) { return pgn(headers, game) };\n  var peg$f1 = function(tagPairs) { return Object.fromEntries(tagPairs) };\n  var peg$f2 = function(tagName, tagValue) { return [tagName, tagValue] };\n  var peg$f3 = function(root, marker) { return { root, marker} };\n  var peg$f4 = function(comment, moves) { return lineToTree(rootNode(comment), ...moves.flat()) };\n  var peg$f5 = function(san, suffix, nag, comment, variations) { return node(san, suffix, nag, comment, variations) };\n  var peg$f6 = function(nag) { return nag };\n  var peg$f7 = function(comment) { return comment.replace(/[\\r\\n]+/g, \" \") };\n  var peg$f8 = function(comment) { return comment.trim() };\n  var peg$f9 = function(line) { return line };\n  var peg$f10 = function(result, comment) { return { result, comment } };\n  var peg$currPos = options.peg$currPos | 0;\n  var peg$savedPos = peg$currPos;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = peg$currPos;\n  var peg$maxFailExpected = options.peg$maxFailExpected || [];\n  var peg$silentFails = options.peg$silentFails | 0;\n\n  var peg$result;\n\n  if (options.startRule) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      if (pos >= peg$posDetailsCache.length) {\n        p = peg$posDetailsCache.length - 1;\n      } else {\n        p = pos;\n        while (!peg$posDetailsCache[--p]) {}\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos, offset) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    var res = {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n    if (offset && peg$source && (typeof peg$source.offset === \"function\")) {\n      res.start = peg$source.offset(res.start);\n      res.end = peg$source.offset(res.end);\n    }\n    return res;\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsepgn() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parsetagPairSection();\n    s2 = peg$parsemoveTextSection();\n    peg$savedPos = s0;\n    s0 = peg$f0(s1, s2);\n\n    return s0;\n  }\n\n  function peg$parsetagPairSection() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsetagPair();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsetagPair();\n    }\n    s2 = peg$parse_();\n    peg$savedPos = s0;\n    s0 = peg$f1(s1);\n\n    return s0;\n  }\n\n  function peg$parsetagPair() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s2 = peg$c0;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e1); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse_();\n      s4 = peg$parsetagName();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parse_();\n        if (input.charCodeAt(peg$currPos) === 34) {\n          s6 = peg$c1;\n          peg$currPos++;\n        } else {\n          s6 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e2); }\n        }\n        if (s6 !== peg$FAILED) {\n          s7 = peg$parsetagValue();\n          if (input.charCodeAt(peg$currPos) === 34) {\n            s8 = peg$c1;\n            peg$currPos++;\n          } else {\n            s8 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e2); }\n          }\n          if (s8 !== peg$FAILED) {\n            s9 = peg$parse_();\n            if (input.charCodeAt(peg$currPos) === 93) {\n              s10 = peg$c2;\n              peg$currPos++;\n            } else {\n              s10 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e3); }\n            }\n            if (s10 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s0 = peg$f2(s4, s7);\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsetagName() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = input.charAt(peg$currPos);\n    if (peg$r0.test(s2)) {\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e5); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = input.charAt(peg$currPos);\n        if (peg$r0.test(s2)) {\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e5); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e4); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsetagValue() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = input.charAt(peg$currPos);\n    if (peg$r1.test(s2)) {\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e7); }\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = input.charAt(peg$currPos);\n      if (peg$r1.test(s2)) {\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e7); }\n      }\n    }\n    s0 = input.substring(s0, peg$currPos);\n    peg$silentFails--;\n    s1 = peg$FAILED;\n    if (peg$silentFails === 0) { peg$fail(peg$e6); }\n\n    return s0;\n  }\n\n  function peg$parsemoveTextSection() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parseline();\n    s2 = peg$parse_();\n    s3 = peg$parsegameTerminationMarker();\n    if (s3 === peg$FAILED) {\n      s3 = null;\n    }\n    s4 = peg$parse_();\n    peg$savedPos = s0;\n    s0 = peg$f3(s1, s3);\n\n    return s0;\n  }\n\n  function peg$parseline() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecomment();\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    s2 = [];\n    s3 = peg$parsemove();\n    while (s3 !== peg$FAILED) {\n      s2.push(s3);\n      s3 = peg$parsemove();\n    }\n    peg$savedPos = s0;\n    s0 = peg$f4(s1, s2);\n\n    return s0;\n  }\n\n  function peg$parsemove() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    s2 = peg$parsemoveNumber();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    s3 = peg$parse_();\n    s4 = peg$parsesan();\n    if (s4 !== peg$FAILED) {\n      s5 = peg$parsesuffixAnnotation();\n      if (s5 === peg$FAILED) {\n        s5 = null;\n      }\n      s6 = [];\n      s7 = peg$parsenag();\n      while (s7 !== peg$FAILED) {\n        s6.push(s7);\n        s7 = peg$parsenag();\n      }\n      s7 = peg$parse_();\n      s8 = peg$parsecomment();\n      if (s8 === peg$FAILED) {\n        s8 = null;\n      }\n      s9 = [];\n      s10 = peg$parsevariation();\n      while (s10 !== peg$FAILED) {\n        s9.push(s10);\n        s10 = peg$parsevariation();\n      }\n      peg$savedPos = s0;\n      s0 = peg$f5(s4, s5, s6, s8, s9);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveNumber() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = input.charAt(peg$currPos);\n    if (peg$r2.test(s2)) {\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e9); }\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = input.charAt(peg$currPos);\n      if (peg$r2.test(s2)) {\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e9); }\n      }\n    }\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s2 = peg$c3;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e10); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parse_();\n      s4 = [];\n      s5 = input.charAt(peg$currPos);\n      if (peg$r3.test(s5)) {\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e11); }\n      }\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = input.charAt(peg$currPos);\n        if (peg$r3.test(s5)) {\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e11); }\n        }\n      }\n      s1 = [s1, s2, s3, s4];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e8); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesan() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (input.substr(peg$currPos, 5) === peg$c4) {\n      s2 = peg$c4;\n      peg$currPos += 5;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e13); }\n    }\n    if (s2 === peg$FAILED) {\n      if (input.substr(peg$currPos, 3) === peg$c5) {\n        s2 = peg$c5;\n        peg$currPos += 3;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e14); }\n      }\n      if (s2 === peg$FAILED) {\n        if (input.substr(peg$currPos, 5) === peg$c6) {\n          s2 = peg$c6;\n          peg$currPos += 5;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e15); }\n        }\n        if (s2 === peg$FAILED) {\n          if (input.substr(peg$currPos, 3) === peg$c7) {\n            s2 = peg$c7;\n            peg$currPos += 3;\n          } else {\n            s2 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e16); }\n          }\n          if (s2 === peg$FAILED) {\n            s2 = peg$currPos;\n            s3 = input.charAt(peg$currPos);\n            if (peg$r0.test(s3)) {\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e5); }\n            }\n            if (s3 !== peg$FAILED) {\n              s4 = [];\n              s5 = input.charAt(peg$currPos);\n              if (peg$r4.test(s5)) {\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e17); }\n              }\n              if (s5 !== peg$FAILED) {\n                while (s5 !== peg$FAILED) {\n                  s4.push(s5);\n                  s5 = input.charAt(peg$currPos);\n                  if (peg$r4.test(s5)) {\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e17); }\n                  }\n                }\n              } else {\n                s4 = peg$FAILED;\n              }\n              if (s4 !== peg$FAILED) {\n                s3 = [s3, s4];\n                s2 = s3;\n              } else {\n                peg$currPos = s2;\n                s2 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s2;\n              s2 = peg$FAILED;\n            }\n          }\n        }\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = input.charAt(peg$currPos);\n      if (peg$r5.test(s3)) {\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e18); }\n      }\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      s2 = [s2, s3];\n      s1 = s2;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e12); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsesuffixAnnotation() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = input.charAt(peg$currPos);\n    if (peg$r6.test(s2)) {\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e20); }\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      if (s1.length >= 2) {\n        s2 = peg$FAILED;\n      } else {\n        s2 = input.charAt(peg$currPos);\n        if (peg$r6.test(s2)) {\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e20); }\n        }\n      }\n    }\n    if (s1.length < 1) {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    } else {\n      s0 = s1;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e19); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsenag() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (input.charCodeAt(peg$currPos) === 36) {\n      s2 = peg$c8;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e22); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$currPos;\n      s4 = [];\n      s5 = input.charAt(peg$currPos);\n      if (peg$r2.test(s5)) {\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e9); }\n      }\n      if (s5 !== peg$FAILED) {\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = input.charAt(peg$currPos);\n          if (peg$r2.test(s5)) {\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e9); }\n          }\n        }\n      } else {\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s3 = input.substring(s3, peg$currPos);\n      } else {\n        s3 = s4;\n      }\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f6(s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e21); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomment() {\n    var s0;\n\n    s0 = peg$parsebraceComment();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parserestOfLineComment();\n    }\n\n    return s0;\n  }\n\n  function peg$parsebraceComment() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s1 = peg$c9;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e24); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = input.charAt(peg$currPos);\n      if (peg$r7.test(s4)) {\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e25); }\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = input.charAt(peg$currPos);\n        if (peg$r7.test(s4)) {\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e25); }\n        }\n      }\n      s2 = input.substring(s2, peg$currPos);\n      if (input.charCodeAt(peg$currPos) === 125) {\n        s3 = peg$c10;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e26); }\n      }\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f7(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e23); }\n    }\n\n    return s0;\n  }\n\n  function peg$parserestOfLineComment() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 59) {\n      s1 = peg$c11;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e28); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = [];\n      s4 = input.charAt(peg$currPos);\n      if (peg$r8.test(s4)) {\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e29); }\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = input.charAt(peg$currPos);\n        if (peg$r8.test(s4)) {\n          peg$currPos++;\n        } else {\n          s4 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e29); }\n        }\n      }\n      s2 = input.substring(s2, peg$currPos);\n      peg$savedPos = s0;\n      s0 = peg$f8(s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e27); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsevariation() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (input.charCodeAt(peg$currPos) === 40) {\n      s2 = peg$c12;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e31); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseline();\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parse_();\n        if (input.charCodeAt(peg$currPos) === 41) {\n          s5 = peg$c13;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e32); }\n        }\n        if (s5 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f9(s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e30); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsegameTerminationMarker() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 3) === peg$c14) {\n      s1 = peg$c14;\n      peg$currPos += 3;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e34); }\n    }\n    if (s1 === peg$FAILED) {\n      if (input.substr(peg$currPos, 3) === peg$c15) {\n        s1 = peg$c15;\n        peg$currPos += 3;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e35); }\n      }\n      if (s1 === peg$FAILED) {\n        if (input.substr(peg$currPos, 7) === peg$c16) {\n          s1 = peg$c16;\n          peg$currPos += 7;\n        } else {\n          s1 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e36); }\n        }\n        if (s1 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 42) {\n            s1 = peg$c17;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e37); }\n          }\n        }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse_();\n      s3 = peg$parsecomment();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f10(s1, s3);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e33); }\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = [];\n    s1 = input.charAt(peg$currPos);\n    if (peg$r9.test(s1)) {\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e39); }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = input.charAt(peg$currPos);\n      if (peg$r9.test(s1)) {\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e39); }\n      }\n    }\n    peg$silentFails--;\n    s1 = peg$FAILED;\n    if (peg$silentFails === 0) { peg$fail(peg$e38); }\n\n    return s0;\n  }\n\n  peg$result = peg$startRuleFunction();\n\n  if (options.peg$library) {\n    return /** @type {any} */ ({\n      peg$result,\n      peg$currPos,\n      peg$FAILED,\n      peg$maxFailExpected,\n      peg$maxFailPos\n    });\n  }\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  StartRules: [\"pgn\"],\n  SyntaxError: peg$SyntaxError,\n  parse: peg$parse\n};\n", "/**\n * @license\n * Copyright (c) 2025, Jeff Hlywa (jhlywa@gmail.com)\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * 1. Redistributions of source code must retain the above copyright notice,\n *    this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright notice,\n *    this list of conditions and the following disclaimer in the documentation\n *    and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport { parse } from './pgn'\n\nconst MASK64 = 0xffffffffffffffffn\n\nfunction rotl(x: bigint, k: bigint): bigint {\n  return ((x << k) | (x >> (64n - k))) & 0xffffffffffffffffn\n}\n\nfunction wrappingMul(x: bigint, y: bigint) {\n  return (x * y) & MASK64\n}\n\n// xoroshiro128**\nexport function xoroshiro128(state: bigint) {\n  return function () {\n    let s0 = BigInt(state & MASK64)\n    let s1 = BigInt((state >> 64n) & MASK64)\n\n    const result = wrappingMul(rotl(wrappingMul(s0, 5n), 7n), 9n)\n\n    s1 ^= s0\n    s0 = (rotl(s0, 24n) ^ s1 ^ (s1 << 16n)) & MASK64\n    s1 = rotl(s1, 37n)\n\n    state = (s1 << 64n) | s0\n\n    return result\n  }\n}\n\nconst rand = xoroshiro128(0xa187eb39cdcaed8f31c4b365b102e01en)\n\nconst PIECE_KEYS = Array.from({ length: 2 }, () =>\n  Array.from({ length: 6 }, () => Array.from({ length: 128 }, () => rand())),\n)\n\nconst EP_KEYS = Array.from({ length: 8 }, () => rand())\n\nconst CASTLING_KEYS = Array.from({ length: 16 }, () => rand())\n\nconst SIDE_KEY = rand()\n\nexport const WHITE = 'w'\nexport const BLACK = 'b'\n\nexport const PAWN = 'p'\nexport const KNIGHT = 'n'\nexport const BISHOP = 'b'\nexport const ROOK = 'r'\nexport const QUEEN = 'q'\nexport const KING = 'k'\n\nexport type Color = 'w' | 'b'\nexport type PieceSymbol = 'p' | 'n' | 'b' | 'r' | 'q' | 'k'\n\n// prettier-ignore\nexport type Square =\n    'a8' | 'b8' | 'c8' | 'd8' | 'e8' | 'f8' | 'g8' | 'h8' |\n    'a7' | 'b7' | 'c7' | 'd7' | 'e7' | 'f7' | 'g7' | 'h7' |\n    'a6' | 'b6' | 'c6' | 'd6' | 'e6' | 'f6' | 'g6' | 'h6' |\n    'a5' | 'b5' | 'c5' | 'd5' | 'e5' | 'f5' | 'g5' | 'h5' |\n    'a4' | 'b4' | 'c4' | 'd4' | 'e4' | 'f4' | 'g4' | 'h4' |\n    'a3' | 'b3' | 'c3' | 'd3' | 'e3' | 'f3' | 'g3' | 'h3' |\n    'a2' | 'b2' | 'c2' | 'd2' | 'e2' | 'f2' | 'g2' | 'h2' |\n    'a1' | 'b1' | 'c1' | 'd1' | 'e1' | 'f1' | 'g1' | 'h1'\n\nexport const DEFAULT_POSITION =\n  'rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1'\n\nexport type Piece = {\n  color: Color\n  type: PieceSymbol\n}\n\ntype InternalMove = {\n  color: Color\n  from: number\n  to: number\n  piece: PieceSymbol\n  captured?: PieceSymbol\n  promotion?: PieceSymbol\n  flags: number\n}\n\ninterface History {\n  move: InternalMove\n  kings: Record<Color, number>\n  turn: Color\n  castling: Record<Color, number>\n  epSquare: number\n  halfMoves: number\n  moveNumber: number\n}\n\nexport class Move {\n  color: Color\n  from: Square\n  to: Square\n  piece: PieceSymbol\n  captured?: PieceSymbol\n  promotion?: PieceSymbol\n\n  /**\n   * @deprecated This field is deprecated and will be removed in version 2.0.0.\n   * Please use move descriptor functions instead: `isCapture`, `isPromotion`,\n   * `isEnPassant`, `isKingsideCastle`, `isQueensideCastle`, `isCastle`, and\n   * `isBigPawn`\n   */\n  flags: string\n\n  san: string\n  lan: string\n  before: string\n  after: string\n\n  constructor(chess: Chess, internal: InternalMove) {\n    const { color, piece, from, to, flags, captured, promotion } = internal\n\n    const fromAlgebraic = algebraic(from)\n    const toAlgebraic = algebraic(to)\n\n    this.color = color\n    this.piece = piece\n    this.from = fromAlgebraic\n    this.to = toAlgebraic\n\n    /*\n     * HACK: The chess['_method']() calls below invoke private methods in the\n     * Chess class to generate SAN and FEN. It's a bit of a hack, but makes the\n     * code cleaner elsewhere.\n     */\n\n    this.san = chess['_moveToSan'](internal, chess['_moves']({ legal: true }))\n    this.lan = fromAlgebraic + toAlgebraic\n    this.before = chess.fen()\n\n    // Generate the FEN for the 'after' key\n    chess['_makeMove'](internal)\n    this.after = chess.fen()\n    chess['_undoMove']()\n\n    // Build the text representation of the move flags\n    this.flags = ''\n    for (const flag in BITS) {\n      if (BITS[flag] & flags) {\n        this.flags += FLAGS[flag]\n      }\n    }\n\n    if (captured) {\n      this.captured = captured\n    }\n\n    if (promotion) {\n      this.promotion = promotion\n      this.lan += promotion\n    }\n  }\n\n  isCapture() {\n    return this.flags.indexOf(FLAGS['CAPTURE']) > -1\n  }\n\n  isPromotion() {\n    return this.flags.indexOf(FLAGS['PROMOTION']) > -1\n  }\n\n  isEnPassant() {\n    return this.flags.indexOf(FLAGS['EP_CAPTURE']) > -1\n  }\n\n  isKingsideCastle() {\n    return this.flags.indexOf(FLAGS['KSIDE_CASTLE']) > -1\n  }\n\n  isQueensideCastle() {\n    return this.flags.indexOf(FLAGS['QSIDE_CASTLE']) > -1\n  }\n\n  isBigPawn() {\n    return this.flags.indexOf(FLAGS['BIG_PAWN']) > -1\n  }\n}\n\nconst EMPTY = -1\n\nconst FLAGS: Record<string, string> = {\n  NORMAL: 'n',\n  CAPTURE: 'c',\n  BIG_PAWN: 'b',\n  EP_CAPTURE: 'e',\n  PROMOTION: 'p',\n  KSIDE_CASTLE: 'k',\n  QSIDE_CASTLE: 'q',\n}\n\n// prettier-ignore\nexport const SQUARES: Square[] = [\n  'a8', 'b8', 'c8', 'd8', 'e8', 'f8', 'g8', 'h8',\n  'a7', 'b7', 'c7', 'd7', 'e7', 'f7', 'g7', 'h7',\n  'a6', 'b6', 'c6', 'd6', 'e6', 'f6', 'g6', 'h6',\n  'a5', 'b5', 'c5', 'd5', 'e5', 'f5', 'g5', 'h5',\n  'a4', 'b4', 'c4', 'd4', 'e4', 'f4', 'g4', 'h4',\n  'a3', 'b3', 'c3', 'd3', 'e3', 'f3', 'g3', 'h3',\n  'a2', 'b2', 'c2', 'd2', 'e2', 'f2', 'g2', 'h2',\n  'a1', 'b1', 'c1', 'd1', 'e1', 'f1', 'g1', 'h1'\n]\n\nconst BITS: Record<string, number> = {\n  NORMAL: 1,\n  CAPTURE: 2,\n  BIG_PAWN: 4,\n  EP_CAPTURE: 8,\n  PROMOTION: 16,\n  KSIDE_CASTLE: 32,\n  QSIDE_CASTLE: 64,\n}\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n// these are required, according to spec\nexport const SEVEN_TAG_ROSTER: Record<string, string> = {\n  Event: '?',\n  Site: '?',\n  Date: '????.??.??',\n  Round: '?',\n  White: '?',\n  Black: '?',\n  Result: '*',\n}\n\n/**\n * These nulls are placeholders to fix the order of tags (as they appear in PGN spec); null values will be\n * eliminated in getHeaders()\n */\nconst SUPLEMENTAL_TAGS: Record<string, string | null> = {\n  WhiteTitle: null,\n  BlackTitle: null,\n  WhiteElo: null,\n  BlackElo: null,\n  WhiteUSCF: null,\n  BlackUSCF: null,\n  WhiteNA: null,\n  BlackNA: null,\n  WhiteType: null,\n  BlackType: null,\n  EventDate: null,\n  EventSponsor: null,\n  Section: null,\n  Stage: null,\n  Board: null,\n  Opening: null,\n  Variation: null,\n  SubVariation: null,\n  ECO: null,\n  NIC: null,\n  Time: null,\n  UTCTime: null,\n  UTCDate: null,\n  TimeControl: null,\n  SetUp: null,\n  FEN: null,\n  Termination: null,\n  Annotator: null,\n  Mode: null,\n  PlyCount: null,\n}\n\nconst HEADER_TEMPLATE = {\n  ...SEVEN_TAG_ROSTER,\n  ...SUPLEMENTAL_TAGS,\n}\n/* eslint-enable @typescript-eslint/naming-convention */\n\n/*\n * NOTES ABOUT 0x88 MOVE GENERATION ALGORITHM\n * ----------------------------------------------------------------------------\n * From https://github.com/jhlywa/chess.js/issues/230\n *\n * A lot of people are confused when they first see the internal representation\n * of chess.js. It uses the 0x88 Move Generation Algorithm which internally\n * stores the board as an 8x16 array. This is purely for efficiency but has a\n * couple of interesting benefits:\n *\n * 1. 0x88 offers a very inexpensive \"off the board\" check. Bitwise AND (&) any\n *    square with 0x88, if the result is non-zero then the square is off the\n *    board. For example, assuming a knight square A8 (0 in 0x88 notation),\n *    there are 8 possible directions in which the knight can move. These\n *    directions are relative to the 8x16 board and are stored in the\n *    PIECE_OFFSETS map. One possible move is A8 - 18 (up one square, and two\n *    squares to the left - which is off the board). 0 - 18 = -18 & 0x88 = 0x88\n *    (because of two-complement representation of -18). The non-zero result\n *    means the square is off the board and the move is illegal. Take the\n *    opposite move (from A8 to C7), 0 + 18 = 18 & 0x88 = 0. A result of zero\n *    means the square is on the board.\n *\n * 2. The relative distance (or difference) between two squares on a 8x16 board\n *    is unique and can be used to inexpensively determine if a piece on a\n *    square can attack any other arbitrary square. For example, let's see if a\n *    pawn on E7 can attack E2. The difference between E7 (20) - E2 (100) is\n *    -80. We add 119 to make the ATTACKS array index non-negative (because the\n *    worst case difference is A8 - H1 = -119). The ATTACKS array contains a\n *    bitmask of pieces that can attack from that distance and direction.\n *    ATTACKS[-80 + 119=39] gives us 24 or 0b11000 in binary. Look at the\n *    PIECE_MASKS map to determine the mask for a given piece type. In our pawn\n *    example, we would check to see if 24 & 0x1 is non-zero, which it is\n *    not. So, naturally, a pawn on E7 can't attack a piece on E2. However, a\n *    rook can since 24 & 0x8 is non-zero. The only thing left to check is that\n *    there are no blocking pieces between E7 and E2. That's where the RAYS\n *    array comes in. It provides an offset (in this case 16) to add to E7 (20)\n *    to check for blocking pieces. E7 (20) + 16 = E6 (36) + 16 = E5 (52) etc.\n */\n\n// prettier-ignore\n// eslint-disable-next-line\nconst Ox88: Record<Square, number> = {\n  a8:   0, b8:   1, c8:   2, d8:   3, e8:   4, f8:   5, g8:   6, h8:   7,\n  a7:  16, b7:  17, c7:  18, d7:  19, e7:  20, f7:  21, g7:  22, h7:  23,\n  a6:  32, b6:  33, c6:  34, d6:  35, e6:  36, f6:  37, g6:  38, h6:  39,\n  a5:  48, b5:  49, c5:  50, d5:  51, e5:  52, f5:  53, g5:  54, h5:  55,\n  a4:  64, b4:  65, c4:  66, d4:  67, e4:  68, f4:  69, g4:  70, h4:  71,\n  a3:  80, b3:  81, c3:  82, d3:  83, e3:  84, f3:  85, g3:  86, h3:  87,\n  a2:  96, b2:  97, c2:  98, d2:  99, e2: 100, f2: 101, g2: 102, h2: 103,\n  a1: 112, b1: 113, c1: 114, d1: 115, e1: 116, f1: 117, g1: 118, h1: 119\n}\n\nconst PAWN_OFFSETS = {\n  b: [16, 32, 17, 15],\n  w: [-16, -32, -17, -15],\n}\n\nconst PIECE_OFFSETS = {\n  n: [-18, -33, -31, -14, 18, 33, 31, 14],\n  b: [-17, -15, 17, 15],\n  r: [-16, 1, 16, -1],\n  q: [-17, -16, -15, 1, 17, 16, 15, -1],\n  k: [-17, -16, -15, 1, 17, 16, 15, -1],\n}\n\n// prettier-ignore\nconst ATTACKS = [\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20, 0,\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n  24,24,24,24,24,24,56,  0, 56,24,24,24,24,24,24, 0,\n   0, 0, 0, 0, 0, 2,53, 56, 53, 2, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0, 0,20, 2, 24,  2,20, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0,20, 0, 0, 24,  0, 0,20, 0, 0, 0, 0, 0,\n   0, 0, 0,20, 0, 0, 0, 24,  0, 0, 0,20, 0, 0, 0, 0,\n   0, 0,20, 0, 0, 0, 0, 24,  0, 0, 0, 0,20, 0, 0, 0,\n   0,20, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0,20, 0, 0,\n  20, 0, 0, 0, 0, 0, 0, 24,  0, 0, 0, 0, 0, 0,20\n];\n\n// prettier-ignore\nconst RAYS = [\n   17,  0,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0,  0, 15, 0,\n    0, 17,  0,  0,  0,  0,  0, 16,  0,  0,  0,  0,  0, 15,  0, 0,\n    0,  0, 17,  0,  0,  0,  0, 16,  0,  0,  0,  0, 15,  0,  0, 0,\n    0,  0,  0, 17,  0,  0,  0, 16,  0,  0,  0, 15,  0,  0,  0, 0,\n    0,  0,  0,  0, 17,  0,  0, 16,  0,  0, 15,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0, 17,  0, 16,  0, 15,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0,  0, 17, 16, 15,  0,  0,  0,  0,  0,  0, 0,\n    1,  1,  1,  1,  1,  1,  1,  0, -1, -1,  -1,-1, -1, -1, -1, 0,\n    0,  0,  0,  0,  0,  0,-15,-16,-17,  0,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,  0,-15,  0,-16,  0,-17,  0,  0,  0,  0,  0, 0,\n    0,  0,  0,  0,-15,  0,  0,-16,  0,  0,-17,  0,  0,  0,  0, 0,\n    0,  0,  0,-15,  0,  0,  0,-16,  0,  0,  0,-17,  0,  0,  0, 0,\n    0,  0,-15,  0,  0,  0,  0,-16,  0,  0,  0,  0,-17,  0,  0, 0,\n    0,-15,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,-17,  0, 0,\n  -15,  0,  0,  0,  0,  0,  0,-16,  0,  0,  0,  0,  0,  0,-17\n];\n\nconst PIECE_MASKS = { p: 0x1, n: 0x2, b: 0x4, r: 0x8, q: 0x10, k: 0x20 }\n\nconst SYMBOLS = 'pnbrqkPNBRQK'\n\nconst PROMOTIONS: PieceSymbol[] = [KNIGHT, BISHOP, ROOK, QUEEN]\n\nconst RANK_1 = 7\nconst RANK_2 = 6\n/*\n * const RANK_3 = 5\n * const RANK_4 = 4\n * const RANK_5 = 3\n * const RANK_6 = 2\n */\nconst RANK_7 = 1\nconst RANK_8 = 0\n\nconst SIDES = {\n  [KING]: BITS.KSIDE_CASTLE,\n  [QUEEN]: BITS.QSIDE_CASTLE,\n}\n\nconst ROOKS = {\n  w: [\n    { square: Ox88.a1, flag: BITS.QSIDE_CASTLE },\n    { square: Ox88.h1, flag: BITS.KSIDE_CASTLE },\n  ],\n  b: [\n    { square: Ox88.a8, flag: BITS.QSIDE_CASTLE },\n    { square: Ox88.h8, flag: BITS.KSIDE_CASTLE },\n  ],\n}\n\nconst SECOND_RANK = { b: RANK_7, w: RANK_2 }\n\n// Extracts the zero-based rank of an 0x88 square.\nfunction rank(square: number): number {\n  return square >> 4\n}\n\n// Extracts the zero-based file of an 0x88 square.\nfunction file(square: number): number {\n  return square & 0xf\n}\n\nfunction isDigit(c: string): boolean {\n  return '0123456789'.indexOf(c) !== -1\n}\n\n// Converts a 0x88 square to algebraic notation.\nfunction algebraic(square: number): Square {\n  const f = file(square)\n  const r = rank(square)\n  return ('abcdefgh'.substring(f, f + 1) +\n    '87654321'.substring(r, r + 1)) as Square\n}\n\nfunction swapColor(color: Color): Color {\n  return color === WHITE ? BLACK : WHITE\n}\n\nexport function validateFen(fen: string): { ok: boolean; error?: string } {\n  // 1st criterion: 6 space-seperated fields?\n  const tokens = fen.split(/\\s+/)\n  if (tokens.length !== 6) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: must contain six space-delimited fields',\n    }\n  }\n\n  // 2nd criterion: move number field is a integer value > 0?\n  const moveNumber = parseInt(tokens[5], 10)\n  if (isNaN(moveNumber) || moveNumber <= 0) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: move number must be a positive integer',\n    }\n  }\n\n  // 3rd criterion: half move counter is an integer >= 0?\n  const halfMoves = parseInt(tokens[4], 10)\n  if (isNaN(halfMoves) || halfMoves < 0) {\n    return {\n      ok: false,\n      error:\n        'Invalid FEN: half move counter number must be a non-negative integer',\n    }\n  }\n\n  // 4th criterion: 4th field is a valid e.p.-string?\n  if (!/^(-|[abcdefgh][36])$/.test(tokens[3])) {\n    return { ok: false, error: 'Invalid FEN: en-passant square is invalid' }\n  }\n\n  // 5th criterion: 3th field is a valid castle-string?\n  if (/[^kKqQ-]/.test(tokens[2])) {\n    return { ok: false, error: 'Invalid FEN: castling availability is invalid' }\n  }\n\n  // 6th criterion: 2nd field is \"w\" (white) or \"b\" (black)?\n  if (!/^(w|b)$/.test(tokens[1])) {\n    return { ok: false, error: 'Invalid FEN: side-to-move is invalid' }\n  }\n\n  // 7th criterion: 1st field contains 8 rows?\n  const rows = tokens[0].split('/')\n  if (rows.length !== 8) {\n    return {\n      ok: false,\n      error: \"Invalid FEN: piece data does not contain 8 '/'-delimited rows\",\n    }\n  }\n\n  // 8th criterion: every row is valid?\n  for (let i = 0; i < rows.length; i++) {\n    // check for right sum of fields AND not two numbers in succession\n    let sumFields = 0\n    let previousWasNumber = false\n\n    for (let k = 0; k < rows[i].length; k++) {\n      if (isDigit(rows[i][k])) {\n        if (previousWasNumber) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (consecutive number)',\n          }\n        }\n        sumFields += parseInt(rows[i][k], 10)\n        previousWasNumber = true\n      } else {\n        if (!/^[prnbqkPRNBQK]$/.test(rows[i][k])) {\n          return {\n            ok: false,\n            error: 'Invalid FEN: piece data is invalid (invalid piece)',\n          }\n        }\n        sumFields += 1\n        previousWasNumber = false\n      }\n    }\n    if (sumFields !== 8) {\n      return {\n        ok: false,\n        error: 'Invalid FEN: piece data is invalid (too many squares in rank)',\n      }\n    }\n  }\n\n  // 9th criterion: is en-passant square legal?\n  if (\n    (tokens[3][1] == '3' && tokens[1] == 'w') ||\n    (tokens[3][1] == '6' && tokens[1] == 'b')\n  ) {\n    return { ok: false, error: 'Invalid FEN: illegal en-passant square' }\n  }\n\n  // 10th criterion: does chess position contain exact two kings?\n  const kings = [\n    { color: 'white', regex: /K/g },\n    { color: 'black', regex: /k/g },\n  ]\n\n  for (const { color, regex } of kings) {\n    if (!regex.test(tokens[0])) {\n      return { ok: false, error: `Invalid FEN: missing ${color} king` }\n    }\n\n    if ((tokens[0].match(regex) || []).length > 1) {\n      return { ok: false, error: `Invalid FEN: too many ${color} kings` }\n    }\n  }\n\n  // 11th criterion: are any pawns on the first or eighth rows?\n  if (\n    Array.from(rows[0] + rows[7]).some((char) => char.toUpperCase() === 'P')\n  ) {\n    return {\n      ok: false,\n      error: 'Invalid FEN: some pawns are on the edge rows',\n    }\n  }\n\n  return { ok: true }\n}\n\n// this function is used to uniquely identify ambiguous moves\nfunction getDisambiguator(move: InternalMove, moves: InternalMove[]): string {\n  const from = move.from\n  const to = move.to\n  const piece = move.piece\n\n  let ambiguities = 0\n  let sameRank = 0\n  let sameFile = 0\n\n  for (let i = 0, len = moves.length; i < len; i++) {\n    const ambigFrom = moves[i].from\n    const ambigTo = moves[i].to\n    const ambigPiece = moves[i].piece\n\n    /*\n     * if a move of the same piece type ends on the same to square, we'll need\n     * to add a disambiguator to the algebraic notation\n     */\n    if (piece === ambigPiece && from !== ambigFrom && to === ambigTo) {\n      ambiguities++\n\n      if (rank(from) === rank(ambigFrom)) {\n        sameRank++\n      }\n\n      if (file(from) === file(ambigFrom)) {\n        sameFile++\n      }\n    }\n  }\n\n  if (ambiguities > 0) {\n    if (sameRank > 0 && sameFile > 0) {\n      /*\n       * if there exists a similar moving piece on the same rank and file as\n       * the move in question, use the square as the disambiguator\n       */\n      return algebraic(from)\n    } else if (sameFile > 0) {\n      /*\n       * if the moving piece rests on the same file, use the rank symbol as the\n       * disambiguator\n       */\n      return algebraic(from).charAt(1)\n    } else {\n      // else use the file symbol\n      return algebraic(from).charAt(0)\n    }\n  }\n\n  return ''\n}\n\nfunction addMove(\n  moves: InternalMove[],\n  color: Color,\n  from: number,\n  to: number,\n  piece: PieceSymbol,\n  captured: PieceSymbol | undefined = undefined,\n  flags: number = BITS.NORMAL,\n) {\n  const r = rank(to)\n\n  if (piece === PAWN && (r === RANK_1 || r === RANK_8)) {\n    for (let i = 0; i < PROMOTIONS.length; i++) {\n      const promotion = PROMOTIONS[i]\n      moves.push({\n        color,\n        from,\n        to,\n        piece,\n        captured,\n        promotion,\n        flags: flags | BITS.PROMOTION,\n      })\n    }\n  } else {\n    moves.push({\n      color,\n      from,\n      to,\n      piece,\n      captured,\n      flags,\n    })\n  }\n}\n\nfunction inferPieceType(san: string): PieceSymbol | undefined {\n  let pieceType = san.charAt(0)\n  if (pieceType >= 'a' && pieceType <= 'h') {\n    const matches = san.match(/[a-h]\\d.*[a-h]\\d/)\n    if (matches) {\n      return undefined\n    }\n    return PAWN\n  }\n  pieceType = pieceType.toLowerCase()\n  if (pieceType === 'o') {\n    return KING\n  }\n  return pieceType as PieceSymbol\n}\n\n// parses all of the decorators out of a SAN string\nfunction strippedSan(move: string): string {\n  return move.replace(/=/, '').replace(/[+#]?[?!]*$/, '')\n}\n\nexport class Chess {\n  private _board = new Array<Piece>(128)\n  private _turn: Color = WHITE\n  private _header: Record<string, string | null> = {}\n  private _kings: Record<Color, number> = { w: EMPTY, b: EMPTY }\n  private _epSquare = -1\n  private _halfMoves = 0\n  private _moveNumber = 0\n  private _history: History[] = []\n  private _comments: Record<string, string> = {}\n  private _castling: Record<Color, number> = { w: 0, b: 0 }\n\n  private _hash = 0n\n\n  // tracks number of times a position has been seen for repetition checking\n  private _positionCount = new Map<bigint, number>()\n\n  constructor(fen = DEFAULT_POSITION, { skipValidation = false } = {}) {\n    this.load(fen, { skipValidation })\n  }\n\n  clear({ preserveHeaders = false } = {}) {\n    this._board = new Array<Piece>(128)\n    this._kings = { w: EMPTY, b: EMPTY }\n    this._turn = WHITE\n    this._castling = { w: 0, b: 0 }\n    this._epSquare = EMPTY\n    this._halfMoves = 0\n    this._moveNumber = 1\n    this._history = []\n    this._comments = {}\n    this._header = preserveHeaders ? this._header : { ...HEADER_TEMPLATE }\n    this._hash = this._computeHash()\n    this._positionCount = new Map<bigint, number>()\n\n    /*\n     * Delete the SetUp and FEN headers (if preserved), the board is empty and\n     * these headers don't make sense in this state. They'll get added later\n     * via .load() or .put()\n     */\n    this._header['SetUp'] = null\n    this._header['FEN'] = null\n  }\n\n  load(fen: string, { skipValidation = false, preserveHeaders = false } = {}) {\n    let tokens = fen.split(/\\s+/)\n\n    // append commonly omitted fen tokens\n    if (tokens.length >= 2 && tokens.length < 6) {\n      const adjustments = ['-', '-', '0', '1']\n      fen = tokens.concat(adjustments.slice(-(6 - tokens.length))).join(' ')\n    }\n\n    tokens = fen.split(/\\s+/)\n\n    if (!skipValidation) {\n      const { ok, error } = validateFen(fen)\n      if (!ok) {\n        throw new Error(error)\n      }\n    }\n\n    const position = tokens[0]\n    let square = 0\n\n    this.clear({ preserveHeaders })\n\n    for (let i = 0; i < position.length; i++) {\n      const piece = position.charAt(i)\n\n      if (piece === '/') {\n        square += 8\n      } else if (isDigit(piece)) {\n        square += parseInt(piece, 10)\n      } else {\n        const color = piece < 'a' ? WHITE : BLACK\n        this._put(\n          { type: piece.toLowerCase() as PieceSymbol, color },\n          algebraic(square),\n        )\n        square++\n      }\n    }\n\n    this._turn = tokens[1] as Color\n\n    if (tokens[2].indexOf('K') > -1) {\n      this._castling.w |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('Q') > -1) {\n      this._castling.w |= BITS.QSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('k') > -1) {\n      this._castling.b |= BITS.KSIDE_CASTLE\n    }\n    if (tokens[2].indexOf('q') > -1) {\n      this._castling.b |= BITS.QSIDE_CASTLE\n    }\n\n    this._epSquare = tokens[3] === '-' ? EMPTY : Ox88[tokens[3] as Square]\n    this._halfMoves = parseInt(tokens[4], 10)\n    this._moveNumber = parseInt(tokens[5], 10)\n\n    this._hash = this._computeHash()\n    this._updateSetup(fen)\n    this._incPositionCount()\n  }\n\n  fen({\n    forceEnpassantSquare = false,\n  }: { forceEnpassantSquare?: boolean } = {}) {\n    let empty = 0\n    let fen = ''\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i]) {\n        if (empty > 0) {\n          fen += empty\n          empty = 0\n        }\n        const { color, type: piece } = this._board[i]\n\n        fen += color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n      } else {\n        empty++\n      }\n\n      if ((i + 1) & 0x88) {\n        if (empty > 0) {\n          fen += empty\n        }\n\n        if (i !== Ox88.h1) {\n          fen += '/'\n        }\n\n        empty = 0\n        i += 8\n      }\n    }\n\n    let castling = ''\n    if (this._castling[WHITE] & BITS.KSIDE_CASTLE) {\n      castling += 'K'\n    }\n    if (this._castling[WHITE] & BITS.QSIDE_CASTLE) {\n      castling += 'Q'\n    }\n    if (this._castling[BLACK] & BITS.KSIDE_CASTLE) {\n      castling += 'k'\n    }\n    if (this._castling[BLACK] & BITS.QSIDE_CASTLE) {\n      castling += 'q'\n    }\n\n    // do we have an empty castling flag?\n    castling = castling || '-'\n\n    let epSquare = '-'\n    /*\n     * only print the ep square if en passant is a valid move (pawn is present\n     * and ep capture is not pinned)\n     */\n    if (this._epSquare !== EMPTY) {\n      if (forceEnpassantSquare) {\n        epSquare = algebraic(this._epSquare)\n      } else {\n        const bigPawnSquare = this._epSquare + (this._turn === WHITE ? 16 : -16)\n        const squares = [bigPawnSquare + 1, bigPawnSquare - 1]\n\n        for (const square of squares) {\n          // is the square off the board?\n          if (square & 0x88) {\n            continue\n          }\n\n          const color = this._turn\n\n          // is there a pawn that can capture the epSquare?\n          if (\n            this._board[square]?.color === color &&\n            this._board[square]?.type === PAWN\n          ) {\n            // if the pawn makes an ep capture, does it leave its king in check?\n            this._makeMove({\n              color,\n              from: square,\n              to: this._epSquare,\n              piece: PAWN,\n              captured: PAWN,\n              flags: BITS.EP_CAPTURE,\n            })\n            const isLegal = !this._isKingAttacked(color)\n            this._undoMove()\n\n            // if ep is legal, break and set the ep square in the FEN output\n            if (isLegal) {\n              epSquare = algebraic(this._epSquare)\n              break\n            }\n          }\n        }\n      }\n    }\n\n    return [\n      fen,\n      this._turn,\n      castling,\n      epSquare,\n      this._halfMoves,\n      this._moveNumber,\n    ].join(' ')\n  }\n\n  private _pieceKey(i: number) {\n    if (!this._board[i]) {\n      return 0n\n    }\n\n    const { color, type } = this._board[i]\n\n    const colorIndex = {\n      w: 0,\n      b: 1,\n    }[color]\n\n    const typeIndex = {\n      p: 0,\n      n: 1,\n      b: 2,\n      r: 3,\n      q: 4,\n      k: 5,\n    }[type]\n\n    return PIECE_KEYS[colorIndex][typeIndex][i]\n  }\n\n  private _epKey() {\n    return this._epSquare === EMPTY ? 0n : EP_KEYS[this._epSquare & 7]\n  }\n\n  private _castlingKey() {\n    const index = (this._castling.w >> 5) | (this._castling.b >> 3)\n    return CASTLING_KEYS[index]\n  }\n\n  private _computeHash() {\n    let hash = 0n\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // did we run off the end of the board\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      if (this._board[i]) {\n        hash ^= this._pieceKey(i)\n      }\n    }\n\n    hash ^= this._epKey()\n    hash ^= this._castlingKey()\n\n    if (this._turn === 'b') {\n      hash ^= SIDE_KEY\n    }\n\n    return hash\n  }\n\n  /*\n   * Called when the initial board setup is changed with put() or remove().\n   * modifies the SetUp and FEN properties of the header object. If the FEN\n   * is equal to the default position, the SetUp and FEN are deleted the setup\n   * is only updated if history.length is zero, ie moves haven't been made.\n   */\n  private _updateSetup(fen: string) {\n    if (this._history.length > 0) return\n\n    if (fen !== DEFAULT_POSITION) {\n      this._header['SetUp'] = '1'\n      this._header['FEN'] = fen\n    } else {\n      this._header['SetUp'] = null\n      this._header['FEN'] = null\n    }\n  }\n\n  reset() {\n    this.load(DEFAULT_POSITION)\n  }\n\n  get(square: Square): Piece | undefined {\n    return this._board[Ox88[square]]\n  }\n\n  findPiece(piece: Piece): Square[] {\n    const squares: Square[] = []\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // did we run off the end of the board\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      // if empty square or wrong color\n      if (!this._board[i] || this._board[i]?.color !== piece.color) {\n        continue\n      }\n\n      // check if square contains the requested piece\n      if (\n        this._board[i].color === piece.color &&\n        this._board[i].type === piece.type\n      ) {\n        squares.push(algebraic(i))\n      }\n    }\n\n    return squares\n  }\n\n  put(\n    { type, color }: { type: PieceSymbol; color: Color },\n    square: Square,\n  ): boolean {\n    if (this._put({ type, color }, square)) {\n      this._updateCastlingRights()\n      this._updateEnPassantSquare()\n      this._updateSetup(this.fen())\n      return true\n    }\n    return false\n  }\n\n  private _set(sq: number, piece: Piece) {\n    this._hash ^= this._pieceKey(sq)\n    this._board[sq] = piece\n    this._hash ^= this._pieceKey(sq)\n  }\n\n  private _put(\n    { type, color }: { type: PieceSymbol; color: Color },\n    square: Square,\n  ): boolean {\n    // check for piece\n    if (SYMBOLS.indexOf(type.toLowerCase()) === -1) {\n      return false\n    }\n\n    // check for valid square\n    if (!(square in Ox88)) {\n      return false\n    }\n\n    const sq = Ox88[square]\n\n    // don't let the user place more than one king\n    if (\n      type == KING &&\n      !(this._kings[color] == EMPTY || this._kings[color] == sq)\n    ) {\n      return false\n    }\n\n    const currentPieceOnSquare = this._board[sq]\n\n    // if one of the kings will be replaced by the piece from args, set the `_kings` respective entry to `EMPTY`\n    if (currentPieceOnSquare && currentPieceOnSquare.type === KING) {\n      this._kings[currentPieceOnSquare.color] = EMPTY\n    }\n\n    this._set(sq, { type: type as PieceSymbol, color: color as Color })\n\n    if (type === KING) {\n      this._kings[color] = sq\n    }\n\n    return true\n  }\n\n  private _clear(sq: number) {\n    this._hash ^= this._pieceKey(sq)\n    delete this._board[sq]\n  }\n\n  remove(square: Square): Piece | undefined {\n    const piece = this.get(square)\n    this._clear(Ox88[square])\n    if (piece && piece.type === KING) {\n      this._kings[piece.color] = EMPTY\n    }\n\n    this._updateCastlingRights()\n    this._updateEnPassantSquare()\n    this._updateSetup(this.fen())\n\n    return piece\n  }\n\n  private _updateCastlingRights() {\n    this._hash ^= this._castlingKey()\n\n    const whiteKingInPlace =\n      this._board[Ox88.e1]?.type === KING &&\n      this._board[Ox88.e1]?.color === WHITE\n    const blackKingInPlace =\n      this._board[Ox88.e8]?.type === KING &&\n      this._board[Ox88.e8]?.color === BLACK\n\n    if (\n      !whiteKingInPlace ||\n      this._board[Ox88.a1]?.type !== ROOK ||\n      this._board[Ox88.a1]?.color !== WHITE\n    ) {\n      this._castling.w &= ~BITS.QSIDE_CASTLE\n    }\n\n    if (\n      !whiteKingInPlace ||\n      this._board[Ox88.h1]?.type !== ROOK ||\n      this._board[Ox88.h1]?.color !== WHITE\n    ) {\n      this._castling.w &= ~BITS.KSIDE_CASTLE\n    }\n\n    if (\n      !blackKingInPlace ||\n      this._board[Ox88.a8]?.type !== ROOK ||\n      this._board[Ox88.a8]?.color !== BLACK\n    ) {\n      this._castling.b &= ~BITS.QSIDE_CASTLE\n    }\n\n    if (\n      !blackKingInPlace ||\n      this._board[Ox88.h8]?.type !== ROOK ||\n      this._board[Ox88.h8]?.color !== BLACK\n    ) {\n      this._castling.b &= ~BITS.KSIDE_CASTLE\n    }\n\n    this._hash ^= this._castlingKey()\n  }\n\n  private _updateEnPassantSquare() {\n    if (this._epSquare === EMPTY) {\n      return\n    }\n\n    const startSquare = this._epSquare + (this._turn === WHITE ? -16 : 16)\n    const currentSquare = this._epSquare + (this._turn === WHITE ? 16 : -16)\n    const attackers = [currentSquare + 1, currentSquare - 1]\n\n    if (\n      this._board[startSquare] !== null ||\n      this._board[this._epSquare] !== null ||\n      this._board[currentSquare]?.color !== swapColor(this._turn) ||\n      this._board[currentSquare]?.type !== PAWN\n    ) {\n      this._hash ^= this._epKey()\n      this._epSquare = EMPTY\n      return\n    }\n\n    const canCapture = (square: number) =>\n      !(square & 0x88) &&\n      this._board[square]?.color === this._turn &&\n      this._board[square]?.type === PAWN\n\n    if (!attackers.some(canCapture)) {\n      this._hash ^= this._epKey()\n      this._epSquare = EMPTY\n    }\n  }\n\n  private _attacked(color: Color, square: number): boolean\n  private _attacked(color: Color, square: number, verbose: false): boolean\n  private _attacked(color: Color, square: number, verbose: true): Square[]\n  private _attacked(color: Color, square: number, verbose?: boolean) {\n    const attackers: Square[] = []\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // did we run off the end of the board\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      // if empty square or wrong color\n      if (this._board[i] === undefined || this._board[i].color !== color) {\n        continue\n      }\n\n      const piece = this._board[i]\n      const difference = i - square\n\n      // skip - to/from square are the same\n      if (difference === 0) {\n        continue\n      }\n\n      const index = difference + 119\n\n      if (ATTACKS[index] & PIECE_MASKS[piece.type]) {\n        if (piece.type === PAWN) {\n          if (\n            (difference > 0 && piece.color === WHITE) ||\n            (difference <= 0 && piece.color === BLACK)\n          ) {\n            if (!verbose) {\n              return true\n            } else {\n              attackers.push(algebraic(i))\n            }\n          }\n          continue\n        }\n\n        // if the piece is a knight or a king\n        if (piece.type === 'n' || piece.type === 'k') {\n          if (!verbose) {\n            return true\n          } else {\n            attackers.push(algebraic(i))\n            continue\n          }\n        }\n\n        const offset = RAYS[index]\n        let j = i + offset\n\n        let blocked = false\n        while (j !== square) {\n          if (this._board[j] != null) {\n            blocked = true\n            break\n          }\n          j += offset\n        }\n\n        if (!blocked) {\n          if (!verbose) {\n            return true\n          } else {\n            attackers.push(algebraic(i))\n            continue\n          }\n        }\n      }\n    }\n\n    if (verbose) {\n      return attackers\n    } else {\n      return false\n    }\n  }\n\n  attackers(square: Square, attackedBy?: Color): Square[] {\n    if (!attackedBy) {\n      return this._attacked(this._turn, Ox88[square], true)\n    } else {\n      return this._attacked(attackedBy, Ox88[square], true)\n    }\n  }\n\n  private _isKingAttacked(color: Color): boolean {\n    const square = this._kings[color]\n    return square === -1 ? false : this._attacked(swapColor(color), square)\n  }\n\n  hash(): string {\n    return this._hash.toString(16)\n  }\n\n  isAttacked(square: Square, attackedBy: Color): boolean {\n    return this._attacked(attackedBy, Ox88[square])\n  }\n\n  isCheck(): boolean {\n    return this._isKingAttacked(this._turn)\n  }\n\n  inCheck(): boolean {\n    return this.isCheck()\n  }\n\n  isCheckmate(): boolean {\n    return this.isCheck() && this._moves().length === 0\n  }\n\n  isStalemate(): boolean {\n    return !this.isCheck() && this._moves().length === 0\n  }\n\n  isInsufficientMaterial(): boolean {\n    /*\n     * k.b. vs k.b. (of opposite colors) with mate in 1:\n     * 8/8/8/8/1b6/8/B1k5/K7 b - - 0 1\n     *\n     * k.b. vs k.n. with mate in 1:\n     * 8/8/8/8/1n6/8/B7/K1k5 b - - 2 1\n     */\n    const pieces: Record<PieceSymbol, number> = {\n      b: 0,\n      n: 0,\n      r: 0,\n      q: 0,\n      k: 0,\n      p: 0,\n    }\n    const bishops = []\n    let numPieces = 0\n    let squareColor = 0\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      squareColor = (squareColor + 1) % 2\n      if (i & 0x88) {\n        i += 7\n        continue\n      }\n\n      const piece = this._board[i]\n      if (piece) {\n        pieces[piece.type] = piece.type in pieces ? pieces[piece.type] + 1 : 1\n        if (piece.type === BISHOP) {\n          bishops.push(squareColor)\n        }\n        numPieces++\n      }\n    }\n\n    // k vs. k\n    if (numPieces === 2) {\n      return true\n    } else if (\n      // k vs. kn .... or .... k vs. kb\n      numPieces === 3 &&\n      (pieces[BISHOP] === 1 || pieces[KNIGHT] === 1)\n    ) {\n      return true\n    } else if (numPieces === pieces[BISHOP] + 2) {\n      // kb vs. kb where any number of bishops are all on the same color\n      let sum = 0\n      const len = bishops.length\n      for (let i = 0; i < len; i++) {\n        sum += bishops[i]\n      }\n      if (sum === 0 || sum === len) {\n        return true\n      }\n    }\n\n    return false\n  }\n\n  isThreefoldRepetition(): boolean {\n    return this._getPositionCount(this._hash) >= 3\n  }\n\n  isDrawByFiftyMoves(): boolean {\n    return this._halfMoves >= 100 // 50 moves per side = 100 half moves\n  }\n\n  isDraw(): boolean {\n    return (\n      this.isDrawByFiftyMoves() ||\n      this.isStalemate() ||\n      this.isInsufficientMaterial() ||\n      this.isThreefoldRepetition()\n    )\n  }\n\n  isGameOver(): boolean {\n    return this.isCheckmate() || this.isDraw()\n  }\n\n  moves(): string[]\n  moves({ square }: { square: Square }): string[]\n  moves({ piece }: { piece: PieceSymbol }): string[]\n\n  moves({ square, piece }: { square: Square; piece: PieceSymbol }): string[]\n\n  moves({ verbose, square }: { verbose: true; square?: Square }): Move[]\n  moves({ verbose, square }: { verbose: false; square?: Square }): string[]\n  moves({\n    verbose,\n    square,\n  }: {\n    verbose?: boolean\n    square?: Square\n  }): string[] | Move[]\n\n  moves({ verbose, piece }: { verbose: true; piece?: PieceSymbol }): Move[]\n  moves({ verbose, piece }: { verbose: false; piece?: PieceSymbol }): string[]\n  moves({\n    verbose,\n    piece,\n  }: {\n    verbose?: boolean\n    piece?: PieceSymbol\n  }): string[] | Move[]\n\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose: true\n    square?: Square\n    piece?: PieceSymbol\n  }): Move[]\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose: false\n    square?: Square\n    piece?: PieceSymbol\n  }): string[]\n  moves({\n    verbose,\n    square,\n    piece,\n  }: {\n    verbose?: boolean\n    square?: Square\n    piece?: PieceSymbol\n  }): string[] | Move[]\n\n  moves({ square, piece }: { square?: Square; piece?: PieceSymbol }): Move[]\n\n  moves({\n    verbose = false,\n    square = undefined,\n    piece = undefined,\n  }: { verbose?: boolean; square?: Square; piece?: PieceSymbol } = {}) {\n    const moves = this._moves({ square, piece })\n\n    if (verbose) {\n      return moves.map((move) => new Move(this, move))\n    } else {\n      return moves.map((move) => this._moveToSan(move, moves))\n    }\n  }\n\n  private _moves({\n    legal = true,\n    piece = undefined,\n    square = undefined,\n  }: {\n    legal?: boolean\n    piece?: PieceSymbol\n    square?: Square\n  } = {}): InternalMove[] {\n    const forSquare = square ? (square.toLowerCase() as Square) : undefined\n    const forPiece = piece?.toLowerCase()\n\n    const moves: InternalMove[] = []\n    const us = this._turn\n    const them = swapColor(us)\n\n    let firstSquare = Ox88.a8\n    let lastSquare = Ox88.h1\n    let singleSquare = false\n\n    // are we generating moves for a single square?\n    if (forSquare) {\n      // illegal square, return empty moves\n      if (!(forSquare in Ox88)) {\n        return []\n      } else {\n        firstSquare = lastSquare = Ox88[forSquare]\n        singleSquare = true\n      }\n    }\n\n    for (let from = firstSquare; from <= lastSquare; from++) {\n      // did we run off the end of the board\n      if (from & 0x88) {\n        from += 7\n        continue\n      }\n\n      // empty square or opponent, skip\n      if (!this._board[from] || this._board[from].color === them) {\n        continue\n      }\n      const { type } = this._board[from]\n\n      let to: number\n      if (type === PAWN) {\n        if (forPiece && forPiece !== type) continue\n\n        // single square, non-capturing\n        to = from + PAWN_OFFSETS[us][0]\n        if (!this._board[to]) {\n          addMove(moves, us, from, to, PAWN)\n\n          // double square\n          to = from + PAWN_OFFSETS[us][1]\n          if (SECOND_RANK[us] === rank(from) && !this._board[to]) {\n            addMove(moves, us, from, to, PAWN, undefined, BITS.BIG_PAWN)\n          }\n        }\n\n        // pawn captures\n        for (let j = 2; j < 4; j++) {\n          to = from + PAWN_OFFSETS[us][j]\n          if (to & 0x88) continue\n\n          if (this._board[to]?.color === them) {\n            addMove(\n              moves,\n              us,\n              from,\n              to,\n              PAWN,\n              this._board[to].type,\n              BITS.CAPTURE,\n            )\n          } else if (to === this._epSquare) {\n            addMove(moves, us, from, to, PAWN, PAWN, BITS.EP_CAPTURE)\n          }\n        }\n      } else {\n        if (forPiece && forPiece !== type) continue\n\n        for (let j = 0, len = PIECE_OFFSETS[type].length; j < len; j++) {\n          const offset = PIECE_OFFSETS[type][j]\n          to = from\n\n          while (true) {\n            to += offset\n            if (to & 0x88) break\n\n            if (!this._board[to]) {\n              addMove(moves, us, from, to, type)\n            } else {\n              // own color, stop loop\n              if (this._board[to].color === us) break\n\n              addMove(\n                moves,\n                us,\n                from,\n                to,\n                type,\n                this._board[to].type,\n                BITS.CAPTURE,\n              )\n              break\n            }\n\n            /* break, if knight or king */\n            if (type === KNIGHT || type === KING) break\n          }\n        }\n      }\n    }\n\n    /*\n     * check for castling if we're:\n     *   a) generating all moves, or\n     *   b) doing single square move generation on the king's square\n     */\n\n    if (forPiece === undefined || forPiece === KING) {\n      if (!singleSquare || lastSquare === this._kings[us]) {\n        // king-side castling\n        if (this._castling[us] & BITS.KSIDE_CASTLE) {\n          const castlingFrom = this._kings[us]\n          const castlingTo = castlingFrom + 2\n\n          if (\n            !this._board[castlingFrom + 1] &&\n            !this._board[castlingTo] &&\n            !this._attacked(them, this._kings[us]) &&\n            !this._attacked(them, castlingFrom + 1) &&\n            !this._attacked(them, castlingTo)\n          ) {\n            addMove(\n              moves,\n              us,\n              this._kings[us],\n              castlingTo,\n              KING,\n              undefined,\n              BITS.KSIDE_CASTLE,\n            )\n          }\n        }\n\n        // queen-side castling\n        if (this._castling[us] & BITS.QSIDE_CASTLE) {\n          const castlingFrom = this._kings[us]\n          const castlingTo = castlingFrom - 2\n\n          if (\n            !this._board[castlingFrom - 1] &&\n            !this._board[castlingFrom - 2] &&\n            !this._board[castlingFrom - 3] &&\n            !this._attacked(them, this._kings[us]) &&\n            !this._attacked(them, castlingFrom - 1) &&\n            !this._attacked(them, castlingTo)\n          ) {\n            addMove(\n              moves,\n              us,\n              this._kings[us],\n              castlingTo,\n              KING,\n              undefined,\n              BITS.QSIDE_CASTLE,\n            )\n          }\n        }\n      }\n    }\n\n    /*\n     * return all pseudo-legal moves (this includes moves that allow the king\n     * to be captured)\n     */\n    if (!legal || this._kings[us] === -1) {\n      return moves\n    }\n\n    // filter out illegal moves\n    const legalMoves = []\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i])\n      if (!this._isKingAttacked(us)) {\n        legalMoves.push(moves[i])\n      }\n      this._undoMove()\n    }\n\n    return legalMoves\n  }\n\n  move(\n    move: string | { from: string; to: string; promotion?: string },\n    { strict = false }: { strict?: boolean } = {},\n  ): Move {\n    /*\n     * The move function can be called with in the following parameters:\n     *\n     * .move('Nxb7')       <- argument is a case-sensitive SAN string\n     *\n     * .move({ from: 'h7', <- argument is a move object\n     *         to :'h8',\n     *         promotion: 'q' })\n     *\n     *\n     * An optional strict argument may be supplied to tell chess.js to\n     * strictly follow the SAN specification.\n     */\n\n    let moveObj = null\n\n    if (typeof move === 'string') {\n      moveObj = this._moveFromSan(move, strict)\n    } else if (typeof move === 'object') {\n      const moves = this._moves()\n\n      // convert the pretty move object to an ugly move object\n      for (let i = 0, len = moves.length; i < len; i++) {\n        if (\n          move.from === algebraic(moves[i].from) &&\n          move.to === algebraic(moves[i].to) &&\n          (!('promotion' in moves[i]) || move.promotion === moves[i].promotion)\n        ) {\n          moveObj = moves[i]\n          break\n        }\n      }\n    }\n\n    // failed to find move\n    if (!moveObj) {\n      if (typeof move === 'string') {\n        throw new Error(`Invalid move: ${move}`)\n      } else {\n        throw new Error(`Invalid move: ${JSON.stringify(move)}`)\n      }\n    }\n\n    /*\n     * need to make a copy of move because we can't generate SAN after the move\n     * is made\n     */\n    const prettyMove = new Move(this, moveObj)\n\n    this._makeMove(moveObj)\n    this._incPositionCount()\n    return prettyMove\n  }\n\n  private _push(move: InternalMove) {\n    this._history.push({\n      move,\n      kings: { b: this._kings.b, w: this._kings.w },\n      turn: this._turn,\n      castling: { b: this._castling.b, w: this._castling.w },\n      epSquare: this._epSquare,\n      halfMoves: this._halfMoves,\n      moveNumber: this._moveNumber,\n    })\n  }\n\n  private _movePiece(from: number, to: number) {\n    this._hash ^= this._pieceKey(from)\n\n    this._board[to] = this._board[from]\n    delete this._board[from]\n\n    this._hash ^= this._pieceKey(to)\n  }\n\n  private _makeMove(move: InternalMove) {\n    const us = this._turn\n    const them = swapColor(us)\n    this._push(move)\n\n    this._hash ^= this._epKey()\n    this._hash ^= this._castlingKey()\n\n    if (move.captured) {\n      this._hash ^= this._pieceKey(move.to)\n    }\n\n    this._movePiece(move.from, move.to)\n\n    // if ep capture, remove the captured pawn\n    if (move.flags & BITS.EP_CAPTURE) {\n      if (this._turn === BLACK) {\n        this._clear(move.to - 16)\n      } else {\n        this._clear(move.to + 16)\n      }\n    }\n\n    // if pawn promotion, replace with new piece\n    if (move.promotion) {\n      this._clear(move.to)\n      this._set(move.to, { type: move.promotion, color: us })\n    }\n\n    // if we moved the king\n    if (this._board[move.to].type === KING) {\n      this._kings[us] = move.to\n\n      // if we castled, move the rook next to the king\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        const castlingTo = move.to - 1\n        const castlingFrom = move.to + 1\n        this._movePiece(castlingFrom, castlingTo)\n      } else if (move.flags & BITS.QSIDE_CASTLE) {\n        const castlingTo = move.to + 1\n        const castlingFrom = move.to - 2\n        this._movePiece(castlingFrom, castlingTo)\n      }\n\n      // turn off castling\n      this._castling[us] = 0\n    }\n\n    // turn off castling if we move a rook\n    if (this._castling[us]) {\n      for (let i = 0, len = ROOKS[us].length; i < len; i++) {\n        if (\n          move.from === ROOKS[us][i].square &&\n          this._castling[us] & ROOKS[us][i].flag\n        ) {\n          this._castling[us] ^= ROOKS[us][i].flag\n          break\n        }\n      }\n    }\n\n    // turn off castling if we capture a rook\n    if (this._castling[them]) {\n      for (let i = 0, len = ROOKS[them].length; i < len; i++) {\n        if (\n          move.to === ROOKS[them][i].square &&\n          this._castling[them] & ROOKS[them][i].flag\n        ) {\n          this._castling[them] ^= ROOKS[them][i].flag\n          break\n        }\n      }\n    }\n\n    this._hash ^= this._castlingKey()\n\n    // if big pawn move, update the en passant square\n    if (move.flags & BITS.BIG_PAWN) {\n      let epSquare\n\n      if (us === BLACK) {\n        epSquare = move.to - 16\n      } else {\n        epSquare = move.to + 16\n      }\n\n      if (\n        (!((move.to - 1) & 0x88) &&\n          this._board[move.to - 1]?.type === PAWN &&\n          this._board[move.to - 1]?.color === them) ||\n        (!((move.to + 1) & 0x88) &&\n          this._board[move.to + 1]?.type === PAWN &&\n          this._board[move.to + 1]?.color === them)\n      ) {\n        this._epSquare = epSquare\n        this._hash ^= this._epKey()\n      } else {\n        this._epSquare = EMPTY\n      }\n    } else {\n      this._epSquare = EMPTY\n    }\n\n    // reset the 50 move counter if a pawn is moved or a piece is captured\n    if (move.piece === PAWN) {\n      this._halfMoves = 0\n    } else if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n      this._halfMoves = 0\n    } else {\n      this._halfMoves++\n    }\n\n    if (us === BLACK) {\n      this._moveNumber++\n    }\n\n    this._turn = them\n    this._hash ^= SIDE_KEY\n  }\n\n  undo(): Move | null {\n    const hash = this._hash\n    const move = this._undoMove()\n    if (move) {\n      const prettyMove = new Move(this, move)\n      this._decPositionCount(hash)\n      return prettyMove\n    }\n    return null\n  }\n\n  private _undoMove(): InternalMove | null {\n    const old = this._history.pop()\n    if (old === undefined) {\n      return null\n    }\n\n    this._hash ^= this._epKey()\n    this._hash ^= this._castlingKey()\n\n    const move = old.move\n\n    this._kings = old.kings\n    this._turn = old.turn\n    this._castling = old.castling\n    this._epSquare = old.epSquare\n    this._halfMoves = old.halfMoves\n    this._moveNumber = old.moveNumber\n\n    this._hash ^= this._epKey()\n    this._hash ^= this._castlingKey()\n    this._hash ^= SIDE_KEY\n\n    const us = this._turn\n    const them = swapColor(us)\n\n    this._movePiece(move.to, move.from)\n\n    // to undo any promotions\n    if (move.piece) {\n      this._clear(move.from)\n      this._set(move.from, { type: move.piece, color: us })\n    }\n\n    if (move.captured) {\n      if (move.flags & BITS.EP_CAPTURE) {\n        // en passant capture\n        let index: number\n        if (us === BLACK) {\n          index = move.to - 16\n        } else {\n          index = move.to + 16\n        }\n        this._set(index, { type: PAWN, color: them })\n      } else {\n        // regular capture\n        this._set(move.to, { type: move.captured, color: them })\n      }\n    }\n\n    if (move.flags & (BITS.KSIDE_CASTLE | BITS.QSIDE_CASTLE)) {\n      let castlingTo: number, castlingFrom: number\n      if (move.flags & BITS.KSIDE_CASTLE) {\n        castlingTo = move.to + 1\n        castlingFrom = move.to - 1\n      } else {\n        castlingTo = move.to - 2\n        castlingFrom = move.to + 1\n      }\n      this._movePiece(castlingFrom, castlingTo)\n    }\n\n    return move\n  }\n\n  pgn({\n    newline = '\\n',\n    maxWidth = 0,\n  }: { newline?: string; maxWidth?: number } = {}): string {\n    /*\n     * using the specification from http://www.chessclub.com/help/PGN-spec\n     * example for html usage: .pgn({ max_width: 72, newline_char: \"<br />\" })\n     */\n\n    const result: string[] = []\n    let headerExists = false\n\n    /* add the PGN header information */\n    for (const i in this._header) {\n      /*\n       * TODO: order of enumerated properties in header object is not\n       * guaranteed, see ECMA-262 spec (section 12.6.4)\n       *\n       * By using HEADER_TEMPLATE, the order of tags should be preserved; we\n       * do have to check for null placeholders, though, and omit them\n       */\n      const headerTag = this._header[i]\n      if (headerTag) result.push(`[${i} \"${this._header[i]}\"]` + newline)\n      headerExists = true\n    }\n\n    if (headerExists && this._history.length) {\n      result.push(newline)\n    }\n\n    const appendComment = (moveString: string) => {\n      const comment = this._comments[this.fen()]\n      if (typeof comment !== 'undefined') {\n        const delimiter = moveString.length > 0 ? ' ' : ''\n        moveString = `${moveString}${delimiter}{${comment}}`\n      }\n      return moveString\n    }\n\n    // pop all of history onto reversed_history\n    const reversedHistory = []\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    const moves = []\n    let moveString = ''\n\n    // special case of a commented starting position with no moves\n    if (reversedHistory.length === 0) {\n      moves.push(appendComment(''))\n    }\n\n    // build the list of moves.  a move_string looks like: \"3. e3 e6\"\n    while (reversedHistory.length > 0) {\n      moveString = appendComment(moveString)\n      const move = reversedHistory.pop()\n\n      // make TypeScript stop complaining about move being undefined\n      if (!move) {\n        break\n      }\n\n      // if the position started with black to move, start PGN with #. ...\n      if (!this._history.length && move.color === 'b') {\n        const prefix = `${this._moveNumber}. ...`\n        // is there a comment preceding the first move?\n        moveString = moveString ? `${moveString} ${prefix}` : prefix\n      } else if (move.color === 'w') {\n        // store the previous generated move_string if we have one\n        if (moveString.length) {\n          moves.push(moveString)\n        }\n        moveString = this._moveNumber + '.'\n      }\n\n      moveString =\n        moveString + ' ' + this._moveToSan(move, this._moves({ legal: true }))\n      this._makeMove(move)\n    }\n\n    // are there any other leftover moves?\n    if (moveString.length) {\n      moves.push(appendComment(moveString))\n    }\n\n    // is there a result? (there ALWAYS has to be a result according to spec; see Seven Tag Roster)\n    moves.push(this._header.Result || '*')\n\n    /*\n     * history should be back to what it was before we started generating PGN,\n     * so join together moves\n     */\n    if (maxWidth === 0) {\n      return result.join('') + moves.join(' ')\n    }\n\n    // TODO (jah): huh?\n    const strip = function () {\n      if (result.length > 0 && result[result.length - 1] === ' ') {\n        result.pop()\n        return true\n      }\n      return false\n    }\n\n    // NB: this does not preserve comment whitespace.\n    const wrapComment = function (width: number, move: string) {\n      for (const token of move.split(' ')) {\n        if (!token) {\n          continue\n        }\n        if (width + token.length > maxWidth) {\n          while (strip()) {\n            width--\n          }\n          result.push(newline)\n          width = 0\n        }\n        result.push(token)\n        width += token.length\n        result.push(' ')\n        width++\n      }\n      if (strip()) {\n        width--\n      }\n      return width\n    }\n\n    // wrap the PGN output at max_width\n    let currentWidth = 0\n    for (let i = 0; i < moves.length; i++) {\n      if (currentWidth + moves[i].length > maxWidth) {\n        if (moves[i].includes('{')) {\n          currentWidth = wrapComment(currentWidth, moves[i])\n          continue\n        }\n      }\n      // if the current move will push past max_width\n      if (currentWidth + moves[i].length > maxWidth && i !== 0) {\n        // don't end the line with whitespace\n        if (result[result.length - 1] === ' ') {\n          result.pop()\n        }\n\n        result.push(newline)\n        currentWidth = 0\n      } else if (i !== 0) {\n        result.push(' ')\n        currentWidth++\n      }\n      result.push(moves[i])\n      currentWidth += moves[i].length\n    }\n\n    return result.join('')\n  }\n\n  /**\n   * @deprecated Use `setHeader` and `getHeaders` instead. This method will return null header tags (which is not what you want)\n   */\n  header(...args: string[]): Record<string, string | null> {\n    for (let i = 0; i < args.length; i += 2) {\n      if (typeof args[i] === 'string' && typeof args[i + 1] === 'string') {\n        this._header[args[i]] = args[i + 1]\n      }\n    }\n    return this._header\n  }\n\n  // TODO: value validation per spec\n  setHeader(key: string, value: string): Record<string, string> {\n    this._header[key] = value ?? SEVEN_TAG_ROSTER[key] ?? null\n    return this.getHeaders()\n  }\n\n  removeHeader(key: string): boolean {\n    if (key in this._header) {\n      this._header[key] = SEVEN_TAG_ROSTER[key] || null\n      return true\n    }\n    return false\n  }\n\n  // return only non-null headers (omit placemarker nulls)\n  getHeaders(): Record<string, string> {\n    const nonNullHeaders: Record<string, string> = {}\n    for (const [key, value] of Object.entries(this._header)) {\n      if (value !== null) {\n        nonNullHeaders[key] = value\n      }\n    }\n    return nonNullHeaders\n  }\n\n  loadPgn(\n    pgn: string,\n    {\n      strict = false,\n      newlineChar = '\\r?\\n',\n    }: { strict?: boolean; newlineChar?: string } = {},\n  ) {\n    // If newlineChar is not the default, replace all instances with \\n\n    if (newlineChar !== '\\r?\\n') {\n      pgn = pgn.replace(new RegExp(newlineChar, 'g'), '\\n')\n    }\n\n    const parsedPgn = parse(pgn)\n\n    // Put the board in the starting position\n    this.reset()\n\n    // parse PGN header\n    const headers = parsedPgn.headers\n    let fen = ''\n\n    for (const key in headers) {\n      // check to see user is including fen (possibly with wrong tag case)\n      if (key.toLowerCase() === 'fen') {\n        fen = headers[key]\n      }\n\n      this.header(key, headers[key])\n    }\n\n    /*\n     * the permissive parser should attempt to load a fen tag, even if it's the\n     * wrong case and doesn't include a corresponding [SetUp \"1\"] tag\n     */\n    if (!strict) {\n      if (fen) {\n        this.load(fen, { preserveHeaders: true })\n      }\n    } else {\n      /*\n       * strict parser - load the starting position indicated by [Setup '1']\n       * and [FEN position]\n       */\n      if (headers['SetUp'] === '1') {\n        if (!('FEN' in headers)) {\n          throw new Error(\n            'Invalid PGN: FEN tag must be supplied with SetUp tag',\n          )\n        }\n        // don't clear the headers when loading\n        this.load(headers['FEN'], { preserveHeaders: true })\n      }\n    }\n\n    let node = parsedPgn.root\n\n    while (node) {\n      if (node.move) {\n        const move = this._moveFromSan(node.move, strict)\n\n        if (move == null) {\n          throw new Error(`Invalid move in PGN: ${node.move}`)\n        } else {\n          this._makeMove(move)\n          this._incPositionCount()\n        }\n      }\n\n      if (node.comment !== undefined) {\n        this._comments[this.fen()] = node.comment\n      }\n\n      node = node.variations[0]\n    }\n\n    /*\n     * Per section 8.2.6 of the PGN spec, the Result tag pair must match match\n     * the termination marker. Only do this when headers are present, but the\n     * result tag is missing\n     */\n\n    const result = parsedPgn.result\n    if (\n      result &&\n      Object.keys(this._header).length &&\n      this._header['Result'] !== result\n    ) {\n      this.setHeader('Result', result)\n    }\n  }\n\n  /*\n   * Convert a move from 0x88 coordinates to Standard Algebraic Notation\n   * (SAN)\n   *\n   * @param {boolean} strict Use the strict SAN parser. It will throw errors\n   * on overly disambiguated moves (see below):\n   *\n   * r1bqkbnr/ppp2ppp/2n5/1B1pP3/4P3/8/PPPP2PP/RNBQK1NR b KQkq - 2 4\n   * 4. ... Nge7 is overly disambiguated because the knight on c6 is pinned\n   * 4. ... Ne7 is technically the valid SAN\n   */\n\n  private _moveToSan(move: InternalMove, moves: InternalMove[]): string {\n    let output = ''\n\n    if (move.flags & BITS.KSIDE_CASTLE) {\n      output = 'O-O'\n    } else if (move.flags & BITS.QSIDE_CASTLE) {\n      output = 'O-O-O'\n    } else {\n      if (move.piece !== PAWN) {\n        const disambiguator = getDisambiguator(move, moves)\n        output += move.piece.toUpperCase() + disambiguator\n      }\n\n      if (move.flags & (BITS.CAPTURE | BITS.EP_CAPTURE)) {\n        if (move.piece === PAWN) {\n          output += algebraic(move.from)[0]\n        }\n        output += 'x'\n      }\n\n      output += algebraic(move.to)\n\n      if (move.promotion) {\n        output += '=' + move.promotion.toUpperCase()\n      }\n    }\n\n    this._makeMove(move)\n    if (this.isCheck()) {\n      if (this.isCheckmate()) {\n        output += '#'\n      } else {\n        output += '+'\n      }\n    }\n    this._undoMove()\n\n    return output\n  }\n\n  // convert a move from Standard Algebraic Notation (SAN) to 0x88 coordinates\n  private _moveFromSan(move: string, strict = false): InternalMove | null {\n    // strip off any move decorations: e.g Nf3+?! becomes Nf3\n    let cleanMove = strippedSan(move)\n\n    if (!strict) {\n      if (cleanMove === '0-0') {\n        cleanMove = 'O-O'\n      } else if (cleanMove === '0-0-0') {\n        cleanMove = 'O-O-O'\n      }\n    }\n\n    let pieceType = inferPieceType(cleanMove)\n    let moves = this._moves({ legal: true, piece: pieceType })\n\n    // strict parser\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (cleanMove === strippedSan(this._moveToSan(moves[i], moves))) {\n        return moves[i]\n      }\n    }\n\n    // the strict parser failed\n    if (strict) {\n      return null\n    }\n\n    let piece = undefined\n    let matches = undefined\n    let from = undefined\n    let to = undefined\n    let promotion = undefined\n\n    /*\n     * The default permissive (non-strict) parser allows the user to parse\n     * non-standard chess notations. This parser is only run after the strict\n     * Standard Algebraic Notation (SAN) parser has failed.\n     *\n     * When running the permissive parser, we'll run a regex to grab the piece, the\n     * to/from square, and an optional promotion piece. This regex will\n     * parse common non-standard notation like: Pe2-e4, Rc1c4, Qf3xf7,\n     * f7f8q, b1c3\n     *\n     * NOTE: Some positions and moves may be ambiguous when using the permissive\n     * parser. For example, in this position: 6k1/8/8/B7/8/8/8/BN4K1 w - - 0 1,\n     * the move b1c3 may be interpreted as Nc3 or B1c3 (a disambiguated bishop\n     * move). In these cases, the permissive parser will default to the most\n     * basic interpretation (which is b1c3 parsing to Nc3).\n     */\n\n    let overlyDisambiguated = false\n\n    matches = cleanMove.match(\n      /([pnbrqkPNBRQK])?([a-h][1-8])x?-?([a-h][1-8])([qrbnQRBN])?/,\n      //     piece         from              to       promotion\n    )\n\n    if (matches) {\n      piece = matches[1]\n      from = matches[2] as Square\n      to = matches[3] as Square\n      promotion = matches[4]\n\n      if (from.length == 1) {\n        overlyDisambiguated = true\n      }\n    } else {\n      /*\n       * The [a-h]?[1-8]? portion of the regex below handles moves that may be\n       * overly disambiguated (e.g. Nge7 is unnecessary and non-standard when\n       * there is one legal knight move to e7). In this case, the value of\n       * 'from' variable will be a rank or file, not a square.\n       */\n\n      matches = cleanMove.match(\n        /([pnbrqkPNBRQK])?([a-h]?[1-8]?)x?-?([a-h][1-8])([qrbnQRBN])?/,\n      )\n\n      if (matches) {\n        piece = matches[1]\n        from = matches[2] as Square\n        to = matches[3] as Square\n        promotion = matches[4]\n\n        if (from.length == 1) {\n          overlyDisambiguated = true\n        }\n      }\n    }\n\n    pieceType = inferPieceType(cleanMove)\n    moves = this._moves({\n      legal: true,\n      piece: piece ? (piece as PieceSymbol) : pieceType,\n    })\n\n    if (!to) {\n      return null\n    }\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      if (!from) {\n        // if there is no from square, it could be just 'x' missing from a capture\n        if (\n          cleanMove ===\n          strippedSan(this._moveToSan(moves[i], moves)).replace('x', '')\n        ) {\n          return moves[i]\n        }\n        // hand-compare move properties with the results from our permissive regex\n      } else if (\n        (!piece || piece.toLowerCase() == moves[i].piece) &&\n        Ox88[from] == moves[i].from &&\n        Ox88[to] == moves[i].to &&\n        (!promotion || promotion.toLowerCase() == moves[i].promotion)\n      ) {\n        return moves[i]\n      } else if (overlyDisambiguated) {\n        /*\n         * SPECIAL CASE: we parsed a move string that may have an unneeded\n         * rank/file disambiguator (e.g. Nge7).  The 'from' variable will\n         */\n\n        const square = algebraic(moves[i].from)\n        if (\n          (!piece || piece.toLowerCase() == moves[i].piece) &&\n          Ox88[to] == moves[i].to &&\n          (from == square[0] || from == square[1]) &&\n          (!promotion || promotion.toLowerCase() == moves[i].promotion)\n        ) {\n          return moves[i]\n        }\n      }\n    }\n\n    return null\n  }\n\n  ascii(): string {\n    let s = '   +------------------------+\\n'\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      // display the rank\n      if (file(i) === 0) {\n        s += ' ' + '87654321'[rank(i)] + ' |'\n      }\n\n      if (this._board[i]) {\n        const piece = this._board[i].type\n        const color = this._board[i].color\n        const symbol =\n          color === WHITE ? piece.toUpperCase() : piece.toLowerCase()\n        s += ' ' + symbol + ' '\n      } else {\n        s += ' . '\n      }\n\n      if ((i + 1) & 0x88) {\n        s += '|\\n'\n        i += 8\n      }\n    }\n    s += '   +------------------------+\\n'\n    s += '     a  b  c  d  e  f  g  h'\n\n    return s\n  }\n\n  perft(depth: number): number {\n    const moves = this._moves({ legal: false })\n    let nodes = 0\n    const color = this._turn\n\n    for (let i = 0, len = moves.length; i < len; i++) {\n      this._makeMove(moves[i])\n      if (!this._isKingAttacked(color)) {\n        if (depth - 1 > 0) {\n          nodes += this.perft(depth - 1)\n        } else {\n          nodes++\n        }\n      }\n      this._undoMove()\n    }\n\n    return nodes\n  }\n\n  turn(): Color {\n    return this._turn\n  }\n\n  board(): ({ square: Square; type: PieceSymbol; color: Color } | null)[][] {\n    const output = []\n    let row = []\n\n    for (let i = Ox88.a8; i <= Ox88.h1; i++) {\n      if (this._board[i] == null) {\n        row.push(null)\n      } else {\n        row.push({\n          square: algebraic(i),\n          type: this._board[i].type,\n          color: this._board[i].color,\n        })\n      }\n      if ((i + 1) & 0x88) {\n        output.push(row)\n        row = []\n        i += 8\n      }\n    }\n\n    return output\n  }\n\n  squareColor(square: Square): 'light' | 'dark' | null {\n    if (square in Ox88) {\n      const sq = Ox88[square]\n      return (rank(sq) + file(sq)) % 2 === 0 ? 'light' : 'dark'\n    }\n\n    return null\n  }\n\n  history(): string[]\n  history({ verbose }: { verbose: true }): Move[]\n  history({ verbose }: { verbose: false }): string[]\n  history({ verbose }: { verbose: boolean }): string[] | Move[]\n  history({ verbose = false }: { verbose?: boolean } = {}) {\n    const reversedHistory = []\n    const moveHistory = []\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    while (true) {\n      const move = reversedHistory.pop()\n      if (!move) {\n        break\n      }\n\n      if (verbose) {\n        moveHistory.push(new Move(this, move))\n      } else {\n        moveHistory.push(this._moveToSan(move, this._moves()))\n      }\n      this._makeMove(move)\n    }\n\n    return moveHistory\n  }\n\n  /*\n   * Keeps track of position occurrence counts for the purpose of repetition\n   * checking. Old positions are removed from the map if their counts are reduced to 0.\n   */\n  private _getPositionCount(hash: bigint): number {\n    return this._positionCount.get(hash) ?? 0\n  }\n\n  private _incPositionCount() {\n    this._positionCount.set(\n      this._hash,\n      (this._positionCount.get(this._hash) ?? 0) + 1,\n    )\n  }\n\n  private _decPositionCount(hash: bigint) {\n    const currentCount = this._positionCount.get(hash) ?? 0\n\n    if (currentCount === 1) {\n      this._positionCount.delete(hash)\n    } else {\n      this._positionCount.set(hash, currentCount - 1)\n    }\n  }\n\n  private _pruneComments() {\n    const reversedHistory = []\n    const currentComments: Record<string, string> = {}\n\n    const copyComment = (fen: string) => {\n      if (fen in this._comments) {\n        currentComments[fen] = this._comments[fen]\n      }\n    }\n\n    while (this._history.length > 0) {\n      reversedHistory.push(this._undoMove())\n    }\n\n    copyComment(this.fen())\n\n    while (true) {\n      const move = reversedHistory.pop()\n      if (!move) {\n        break\n      }\n      this._makeMove(move)\n      copyComment(this.fen())\n    }\n    this._comments = currentComments\n  }\n\n  getComment(): string {\n    return this._comments[this.fen()]\n  }\n\n  setComment(comment: string) {\n    this._comments[this.fen()] = comment.replace('{', '[').replace('}', ']')\n  }\n\n  /**\n   * @deprecated Renamed to `removeComment` for consistency\n   */\n  deleteComment(): string {\n    return this.removeComment()\n  }\n\n  removeComment(): string {\n    const comment = this._comments[this.fen()]\n    delete this._comments[this.fen()]\n    return comment\n  }\n\n  getComments(): { fen: string; comment: string }[] {\n    this._pruneComments()\n    return Object.keys(this._comments).map((fen: string) => {\n      return { fen: fen, comment: this._comments[fen] }\n    })\n  }\n\n  /**\n   * @deprecated Renamed to `removeComments` for consistency\n   */\n  deleteComments(): { fen: string; comment: string }[] {\n    return this.removeComments()\n  }\n\n  removeComments(): { fen: string; comment: string }[] {\n    this._pruneComments()\n    return Object.keys(this._comments).map((fen) => {\n      const comment = this._comments[fen]\n      delete this._comments[fen]\n      return { fen: fen, comment: comment }\n    })\n  }\n\n  setCastlingRights(\n    color: Color,\n    rights: Partial<Record<typeof KING | typeof QUEEN, boolean>>,\n  ): boolean {\n    for (const side of [KING, QUEEN] as const) {\n      if (rights[side] !== undefined) {\n        if (rights[side]) {\n          this._castling[color] |= SIDES[side]\n        } else {\n          this._castling[color] &= ~SIDES[side]\n        }\n      }\n    }\n\n    this._updateCastlingRights()\n    const result = this.getCastlingRights(color)\n\n    return (\n      (rights[KING] === undefined || rights[KING] === result[KING]) &&\n      (rights[QUEEN] === undefined || rights[QUEEN] === result[QUEEN])\n    )\n  }\n\n  getCastlingRights(color: Color): { [KING]: boolean; [QUEEN]: boolean } {\n    return {\n      [KING]: (this._castling[color] & SIDES[KING]) !== 0,\n      [QUEEN]: (this._castling[color] & SIDES[QUEEN]) !== 0,\n    }\n  }\n\n  moveNumber(): number {\n    return this._moveNumber\n  }\n}\n"],
  "mappings": "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",
  "names": ["node", "expected", "found", "location", "text", "offset", "_a", "_b", "moveString"]
}
